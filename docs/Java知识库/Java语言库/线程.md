#### 线程的三种方式
- 继承Thread类,本职
```java
package com.threads;
public class TestThread extends Thread{
    public void run() {
        #执行业务代码
    }
}
#启动方式
(new TestThread()).start();
```
- 实现Runnable接口
```java
package com.threads;
public class TestThread implements Runnable{
    public void run() {
        #执行业务代码
    }
}
#启动方式
new Thread(new TestThread).start();
```
- 匿名类的方式
```java
public class TestThread{
    public static void main(String[] args){
        Thread thread1=new Thread(){
            public void run(){
                #执行业务代码
            }
        };
        thread1.start();
    }
}
```
#### 常见方法
- sleep 当前线程暂停
1. 当前线程暂停，其他线程不收影响。
- join 加入到当前线程
1. 所有进程，至少有一个线程即主线程，即main方法开始执行
- setPriority 线程优先级
1. 当线程处于竞争关系的时候，优先级高的线程会有更大的机会获得CPU资源
- yield 临时暂停
1. 当前线程暂停，使得其他线程可以更多的机会获得CPU资源
- setDaemon 守护线程
1. 当一个进程里，所有的线程都是守护线程的时候，结束当前进程；
2. 守护线程通常会被用来做日志，性能统计等工作。


#### 线程同步
- 多个线程对同一数据进行修改时，可能出现数据错误，类似于数据库的中隔离机制
- synchronized 实现线程同步，独占对象机制
```java
 #方法一
 Object someObject=new Object();
 Thread thread1=new Thread(){
     public void run(){
         synchronized (someObject) {//可以是任意对象
            #执行业务代码
         }
     }
 };
 #方法二
 public class xxx{
    #在方法内部修饰
    public void xxTest(){
        synchronized (this) {
            #执行业务代码
        }
    }
    #或在方法前修饰
    public synchronized void xxxTest(){
        #执行业务代码
    }
 }
```
#### 常见线程相关问题
- HashMap和Hashtable的区别<br />
    1.HashMap非线程安全；<br />
    2.Hashtable线程安全

- StringBuffer和StringBuilder的区别   <br />
    1.StringBuffer线程安全;<br />
    2.StringBuilder非线程安全.

- ArrayList和Vector的区别   
    1.Vector线程安全;<br />
    2.ArrayList非线程安全.
- 非线程安全的集合转换为线程安全 (见集合)
- 时间问题：线程安全因为同步，会消耗更多的时间

#### 死锁
产生原因：两个线程：尝试占有两个已经被占用的对象，产生同时等待，一直等待，故产生死锁
```java
public class Test()
{
    public static void main(String[] args){
        Object object1 = new Object();
        Object object2 = new Object();
        #线程1（忽略）
        synchronized (object1) {
           synchronized (object2) {
                            
           }
        }
        #线程2（忽略）
        synchronized (object2) {
           synchronized (object1) {
                                    
           }
        }
    }
}
```